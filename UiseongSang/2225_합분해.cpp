#include <bits/stdc++.h>
using namespace std;
int n,k;
int dp[201][201];

int main() {
    
    // 문제의 목표
    // dp[20][2] -> 2가지 정수를 사용해 20을 만들 수 있는 경우의 수

    // 데이터 삽입
    // for(int i = 0; i <= n; i++){
    //     dp[i][1] = 1;
    // }

    // 점화식 만들어 보기!!
    // 1
    // dp[1][2] =  dp[0][1] + dp[1][1] || dp[1][1] + dp[0][1] 
    // dp[2][2] = 0 + 2, 2 + 0, 1 + 1

    // 2
    // dp[2][2] = dp[0][1] + dp[2][1], dp[1][1] + dp[1][1] 
    // -> dp[0][1], dp[1][1], dp[2][1] = 3

    // 3
    // dp[3][2] =  0 + 3, 3 + 0, 1 + 2 , 2 + 1 
    // -> dp[0][1] + dp[3][1], dp[1][1] + dp[2][1]
    //  dp[0][1] , dp[1][1] , dp[2][1] , dp[3][1]
    
    // 4
    // dp[3][2] =  0 + 4, 4 + 0, 1 + 3 , 3 + 1, 2 + 2 
    //  dp[0][1] , dp[1][1] , dp[2][1] , dp[3][1], dp[4][1]
    // 4를 얻을려면 
    
    // 점화식 점검!!
    // dp[4][2] -> n = 4, k = 2
    // for(int i = 0; i <= n; i++) {
    //     dp[n][k] += dp[i][k-1];
    // }
    // 여기서는 k가 2일 떄 기준

    // 넓게 바라보기
    //만약에 k가 2보다 클떈?
    // int tmp = 1;

    // while(tmp != k) {
    //     ++tmp;
    //     dp[0][tmp] = 1;
    //     for(int i = 1; i <= n; i++) {        
    //         dp[i][tmp] = (dp[i][tmp-1] + dp[i-1][tmp]);
    //     }
    // }
    // -> 오답이 나오므로 메모리제이션 할 떄  % 1000000000를 해줘야 한다.

    // 적용해보기
    // 1. 입력 받기
    cin >> n >> k;

    // 2. k가 1일때는 항상 1가지의 경우수이므로, 데이터 세팅하기
    for(int i = 0; i <= n; i++){
        dp[i][1] = 1;
    }

    // 3. 만든 점화식 적용하기
    int tmp = 1;

    while(tmp != k) {
        ++tmp;
        dp[0][tmp] = 1;
        for(int i = 1; i <= n; i++) {        
            dp[i][tmp] = (dp[i][tmp-1] + dp[i-1][tmp]) % 1000000000;
        }
    }

    // 4. 답 출력
    cout << dp[n][k];

    return 0;
}